<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DetailDLPProjectSeepagesChokage" xml:space="preserve">
    <value>SELECT 
	COUNT(CASE
		WHEN (DM.TYPE like '%Water Seepage%'
			OR DM.TYPE LIKE '%Leakage%') THEN 1
		ELSE NULL
	END) AS TOTALWATERSEEPAGESLEAKAGESUNITS,
	COUNT(CASE
		WHEN DM.TYPE like '%Chokage%' THEN 1
		ELSE NULL
	END) AS TOTLACHOKAGEUNITS
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON M.ID = DM.MAINTENANCE_ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQL;

SELECT SUM(MM.CHOKAGE_UNIT_COMPLETED) AS CHOKAGE_UNIT_COMPLETED,
	SUM(MM.CHOKAGE_PENDING_OWNER_KEY_ARRANGEMENT) AS CHOKAGE_PENDING_OWNER_KEY_ARRANGEMENT,
	SUM(MM.CHOKAGE_UNIT_WORK_IN_PROGRESS) AS CHOKAGE_UNIT_WORK_IN_PROGRESS,
	SUM(MM.WATERSEEPAGE_LEAKAGEUNITS_PENDING_OWNER_KEY_ARRANGEMENT) AS WATERSEEPAGE_LEAKAGEUNITS_PENDING_OWNER_KEY_ARRANGEMENT,
	SUM(MM.WATERSEEPAGE_LEAKAGEUNITS_UNIT_COMPLETED) AS WATERSEEPAGE_LEAKAGEUNITS_UNIT_COMPLETED,
	SUM(MM.WATERSEEPAGE_LEAKAGEUNITS_UNIT_WORK_IN_PROGRESS) AS WATERSEEPAGE_LEAKAGEUNITS_UNIT_WORK_IN_PROGRESS
FROM MAINTENANCE_MONTHLY MM
LEFT JOIN MAINTENANCE M ON M.ID = MM.MAINTENANCE_ID
WHERE M.IS_DELETED IS NOT TRUE
	AND MM.IS_DELETED IS NOT TRUE
	AND @WHERESQL;</value>
  </data>
  <data name="DLPDetailProjectOverview" xml:space="preserve">
    <value>SELECT M.PROJECT_ID,
	SUM(M.PROJECT_TOTAL_UNITS) AS PROJECT_TOTAL_UNITS,
	SUM(MM.UNITS_PURCHASER_COLLECTED_KEYS) AS TOTAL_UNITS_PURCHASER_COLLECTED_KEYS,
	SUM(MM.UNITS_MOVED_IN) AS UNITS_MOVED_IN
FROM MAINTENANCE M
LEFT JOIN MAINTENANCE_MONTHLY MM ON M.ID = MM.MAINTENANCE_ID
WHERE @WHERESQL
GROUP BY M.PROJECT_ID;


SELECT COUNT(CM.ID) AS DEFECTS_CASES_NOT_SUBMITTED
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND SUBMITTED_DATE IS NOT NULL
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLCASES;

SELECT CM.*,
	M.ID AS MAINTENANCEID FROM MAINTENANCE M
LEFT JOIN CASES_MONITORING CM ON M.ID = CM.MAINTENANCE_ID
WHERE M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
AND @WHERESQLCASES;


SELECT DM.*,
	M.ID AS MAINTENANCEID FROM MAINTENANCE M
LEFT JOIN DEFECTS_MONITORING DM ON M.ID = DM.MAINTENANCE_ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
AND @WHERESQLDEFECTS
ORDER BY DM.BLOCK DESC, DM.LEVEL DESC, DM.UNIT DESC;

SELECT COUNT(CM.ID) AS TOTAL
FROM CASES_MONITORING CM;</value>
  </data>
  <data name="DLPDetailProjectOverviewCases" xml:space="preserve">
    <value>SELECT M.PROJECT_ID,
	SUM(M.PROJECT_TOTAL_UNITS) AS PROJECT_TOTAL_UNITS,
	SUM(MM.UNITS_PURCHASER_COLLECTED_KEYS) AS TOTAL_UNITS_PURCHASER_COLLECTED_KEYS,
	SUM(MM.UNITS_MOVED_IN) AS UNITS_MOVED_IN
FROM MAINTENANCE M
LEFT JOIN MAINTENANCE_MONTHLY MM ON M.ID = MM.MAINTENANCE_ID
WHERE @WHERESQL
GROUP BY M.PROJECT_ID;


SELECT COUNT(CM.ID) AS DEFECTS_CASES_NOT_SUBMITTED
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND SUBMITTED_DATE IS NOT NULL
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLCASES;

SELECT CM.CASES_ID,
	CM.BLOCK,
	CM.LEVEL,
	CM.UNIT,
	CM.CASE_NUMBER,
	CM.TAG,
	CM.SUBMITTED_DATE,
	CM.TARGET_COMPLETION_DATE,
	M.ID AS MAINTENANCEID,
	COUNT(DM.ID) AS DEFECTS
FROM MAINTENANCE M
LEFT JOIN CASES_MONITORING CM ON M.ID = CM.MAINTENANCE_ID
LEFT JOIN DEFECTS_MONITORING DM ON CM.CASES_ID = DM.CASES_ID
WHERE M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND CM.TYPE_WARRANTY = 'DLP'
	AND @WHERESQLCASES
GROUP BY CM.CASES_ID,
	CM.BLOCK,
	CM.LEVEL,
	CM.UNIT,
	CM.CASE_NUMBER,
	CM.TAG,
	CM.SUBMITTED_DATE,
	CM.TARGET_COMPLETION_DATE,
	M.ID
ORDER BY CM.BLOCK DESC,
	CM.LEVEL DESC,
	CM.UNIT DESC;

SELECT COUNT(CM.ID) AS TOTAL
FROM CASES_MONITORING CM;</value>
  </data>
  <data name="DLPDetailProjectOverviewDefects" xml:space="preserve">
    <value>SELECT M.PROJECT_ID,
	SUM(M.PROJECT_TOTAL_UNITS) AS PROJECT_TOTAL_UNITS,
	SUM(MM.UNITS_PURCHASER_COLLECTED_KEYS) AS TOTAL_UNITS_PURCHASER_COLLECTED_KEYS,
	SUM(MM.UNITS_MOVED_IN) AS UNITS_MOVED_IN
FROM MAINTENANCE M
LEFT JOIN MAINTENANCE_MONTHLY MM ON M.ID = MM.MAINTENANCE_ID
WHERE @WHERESQL
GROUP BY M.PROJECT_ID;


SELECT COUNT(CM.ID) AS DEFECTS_CASES_NOT_SUBMITTED
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND SUBMITTED_DATE IS NOT NULL
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLCASES;


SELECT DM.BLOCK,
	DM.LEVEL,
	DM.UNIT,
	DM.LOCATION,
	DM.TYPE,
	DM.DESCRIPTION,
	DM.STATUS,
	DM.NB_DAYS_OPEN,
	M.ID AS MAINTENANCEID
FROM MAINTENANCE M
LEFT JOIN DEFECTS_MONITORING DM ON M.ID = DM.MAINTENANCE_ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS
ORDER BY DM.BLOCK DESC,
	DM.LEVEL DESC,
	DM.UNIT DESC;


SELECT COUNT(CM.ID) AS TOTAL
FROM CASES_MONITORING CM;</value>
  </data>
  <data name="DLPDetailProjectUnitView" xml:space="preserve">
    <value>SELECT M.PROJECT_ID,
	SUM(M.PROJECT_TOTAL_UNITS) AS PROJECT_TOTAL_UNITS,
	SUM(MM.UNITS_PURCHASER_COLLECTED_KEYS) AS TOTAL_UNITS_PURCHASER_COLLECTED_KEYS,
	SUM(MM.UNITS_MOVED_IN) AS UNITS_MOVED_IN
FROM MAINTENANCE M
LEFT JOIN MAINTENANCE_MONTHLY MM ON M.ID = MM.MAINTENANCE_ID
WHERE @WHERESQL
GROUP BY M.PROJECT_ID;


SELECT COUNT(CM.ID) AS DEFECTS_CASES_NOT_SUBMITTED
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE TYPE_WARRANTY = 'DLP' AND @WHERESQLCASES AND M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND SUBMITTED_DATE IS NOT NULL;

SELECT DM.BLOCK, DM.LEVEL, DM.UNIT, DM.STATUS,
	M.ID AS MAINTENANCEID FROM MAINTENANCE M
LEFT JOIN DEFECTS_MONITORING DM ON M.ID = DM.MAINTENANCE_ID
WHERE 
	TYPE_WARRANTY = 'DLP' 
	AND @WHERESQLDEFECTS
	AND M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
GROUP BY DM.BLOCK, DM.LEVEL, DM.UNIT, DM.STATUS, MAINTENANCEID
ORDER BY DM.BLOCK DESC, DM.LEVEL DESC, DM.UNIT DESC;

SELECT COUNT(CM.ID) AS TOTAL
FROM CASES_MONITORING CM;</value>
  </data>
  <data name="DLPDetailUnitsOIF1stOutstanding" xml:space="preserve">
    <value>SELECT DM.STATUS,
	DM.TAG,
	M.PROJECT_NAME,
	COUNT(DM.ID) AS TOTAL_STATUS,
	@STARTWEEK AS STARTWEEK,
	@ENDWEEK AS ENDWEEK
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON M.ID = DM.MAINTENANCE_ID
WHERE 
	(DM.CASE_NUMBER LIKE '%-001-H' OR DM.CASE_NUMBER LIKE '%-001')
	AND (LOWER(STATUS) LIKE '%wip%' OR LOWER(STATUS) LIKE '%ps%')
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQL
GROUP BY STATUS,
	DM.TAG,
	M.PROJECT_NAME;</value>
  </data>
  <data name="DLPDetailUnitsOIF1stOverview" xml:space="preserve">
    <value>SELECT STATUS,
	M.PROJECT_NAME,
	COUNT(CM.ID) AS TOTAL_STATUS,
	@STARTWEEK AS StartWeek,
	@ENDWEEK AS EndWeek
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON M.ID = CM.MAINTENANCE_ID
WHERE (CM.CASE_NUMBER LIKE '%-001-H'
	OR CM.CASE_NUMBER LIKE '%-001')
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLCASES
GROUP BY STATUS,
	M.PROJECT_NAME;

SELECT STATUS,
	M.PROJECT_NAME,
	COUNT(DM.ID) AS TOTAL_STATUS,
	@STARTWEEK AS StartWeek,
	@ENDWEEK AS EndWeek
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON M.ID = DM.MAINTENANCE_ID
WHERE (DM.CASE_NUMBER LIKE '%-001-H'
	OR DM.CASE_NUMBER LIKE '%-001')
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS
GROUP BY STATUS,
	M.PROJECT_NAME;</value>
  </data>
  <data name="DLPDetailUnitsOIF1stTimeLine" xml:space="preserve">
    <value>SELECT 
	EXTRACT(MONTH FROM CM.CREATION_DATE) AS MONTH,
	EXTRACT(YEAR FROM CM.CREATION_DATE) AS YEAR,
	CONCAT(EXTRACT(MONTH FROM CM.CREATION_DATE), '-', substring(CAST (EXTRACT(YEAR FROM CM.CREATION_DATE) AS VARCHAR) from 3 for 4)) AS DATE_CONCAT,
	STATUS,
	M.PROJECT_NAME,
	COUNT(CM.ID) AS TOTAL_STATUS
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON M.ID = CM.MAINTENANCE_ID
WHERE 
M.IS_DELETED IS NOT TRUE
AND CM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
AND @WHERESQLCASES
AND (CM.CASE_NUMBER LIKE '%-001-H' OR CM.CASE_NUMBER LIKE '%-001')
GROUP BY MONTH, YEAR , DATE_CONCAT,
	STATUS,
	M.PROJECT_NAME
ORDER BY YEAR, MONTH, DATE_CONCAT;


SELECT
	EXTRACT(MONTH FROM DM.CREATION_DATE) AS MONTH,
	EXTRACT(YEAR FROM DM.CREATION_DATE) AS YEAR,
	CONCAT(EXTRACT(MONTH FROM DM.CREATION_DATE), '-', substring(CAST (EXTRACT(YEAR FROM DM.CREATION_DATE) AS VARCHAR) from 3 for 4)) AS DATE_CONCAT,
	STATUS,
	M.PROJECT_NAME,
	COUNT(DM.ID) AS TOTAL_STATUS
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON M.ID = DM.MAINTENANCE_ID
WHERE 
M.IS_DELETED IS NOT TRUE
AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
AND @WHERESQLDEFECTS
AND (DM.CASE_NUMBER LIKE '%-001-H' OR DM.CASE_NUMBER LIKE '%-001')
GROUP BY 
	YEAR, MONTH, DATE_CONCAT,
	STATUS,
	M.PROJECT_NAME
ORDER BY YEAR, MONTH, DATE_CONCAT;</value>
  </data>
  <data name="DLPDetailUnitsOIF2ndOutstanding" xml:space="preserve">
    <value>SELECT DM.STATUS,
	DM.TAG,
	M.PROJECT_NAME,
	COUNT(DM.ID) AS TOTAL_STATUS,
	@STARTWEEK AS STARTWEEK,
	@ENDWEEK AS ENDWEEK
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON M.ID = DM.MAINTENANCE_ID
WHERE 
	(DM.CASE_NUMBER NOT LIKE '%-002-H' OR DM.CASE_NUMBER NOT LIKE '%-002')
	AND (LOWER(STATUS) LIKE '%wip%' OR LOWER(STATUS) LIKE '%ps%')
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQL
GROUP BY STATUS,
	DM.TAG,
	M.PROJECT_NAME;</value>
  </data>
  <data name="DLPDetailUnitsOIF2ndOverview" xml:space="preserve">
    <value>SELECT STATUS,
	M.PROJECT_NAME,
	COUNT(CM.ID) AS TOTAL_STATUS,
	@STARTWEEK AS StartWeek,
	@ENDWEEK AS EndWeek
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON M.ID = CM.MAINTENANCE_ID
WHERE (CM.CASE_NUMBER LIKE '%-002-H'
	OR CM.CASE_NUMBER LIKE '%-002')
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLCASES
GROUP BY STATUS,
	M.PROJECT_NAME;

SELECT STATUS,
	M.PROJECT_NAME,
	COUNT(DM.ID) AS TOTAL_STATUS,
	@STARTWEEK AS StartWeek,
	@ENDWEEK AS EndWeek
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON M.ID = DM.MAINTENANCE_ID
WHERE (DM.CASE_NUMBER LIKE '%-002-H'
	OR DM.CASE_NUMBER LIKE '%-002')
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS
GROUP BY STATUS,
	M.PROJECT_NAME;</value>
  </data>
  <data name="DLPDetailUnitsOIF2ndTimeLine" xml:space="preserve">
    <value>SELECT 
	EXTRACT(MONTH FROM CM.CREATION_DATE) AS MONTH,
	EXTRACT(YEAR FROM CM.CREATION_DATE) AS YEAR,
	CONCAT(EXTRACT(MONTH FROM CM.CREATION_DATE), '-', substring(CAST (EXTRACT(YEAR FROM CM.CREATION_DATE) AS VARCHAR) from 3 for 4)) AS DATE_CONCAT,
	STATUS,
	M.PROJECT_NAME,
	COUNT(CM.ID) AS TOTAL_STATUS
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON M.ID = CM.MAINTENANCE_ID
WHERE 
M.IS_DELETED IS NOT TRUE
AND CM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
AND @WHERESQLCASES
AND (CM.CASE_NUMBER LIKE '%-002-H' OR CM.CASE_NUMBER LIKE '%-002')
GROUP BY MONTH, YEAR , DATE_CONCAT,
	STATUS,
	M.PROJECT_NAME
ORDER BY YEAR, MONTH, DATE_CONCAT;


SELECT
	EXTRACT(MONTH FROM DM.CREATION_DATE) AS MONTH,
	EXTRACT(YEAR FROM DM.CREATION_DATE) AS YEAR,
	CONCAT(EXTRACT(MONTH FROM DM.CREATION_DATE), '-', substring(CAST (EXTRACT(YEAR FROM DM.CREATION_DATE) AS VARCHAR) from 3 for 4)) AS DATE_CONCAT,
	STATUS,
	M.PROJECT_NAME,
	COUNT(DM.ID) AS TOTAL_STATUS
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON M.ID = DM.MAINTENANCE_ID
WHERE 
M.IS_DELETED IS NOT TRUE
AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
AND @WHERESQLDEFECTS
AND (DM.CASE_NUMBER LIKE '%-002-H' OR DM.CASE_NUMBER LIKE '%-002')
GROUP BY 
	YEAR, MONTH, DATE_CONCAT,
	STATUS,
	M.PROJECT_NAME
ORDER BY YEAR, MONTH, DATE_CONCAT;</value>
  </data>
  <data name="DLPTotalWorkersOnSiteTimeline" xml:space="preserve">
    <value>SELECT
	CONCAT(EXTRACT(MONTH FROM MM.MONTH), '-',  substring(CAST (EXTRACT(YEAR FROM MM.MONTH) AS VARCHAR) from 3 for 4)) AS MONTH,
	SUM(MM.TOTAL_WORKERS_ON_SITE) AS TOTAL_WORKERS_ON_SITE,
	SUM(MM.TOTAL_WH_WORKERS_ON_SITE) AS TOTAL_WH_WORKERS_ON_SITE
FROM MAINTENANCE_MONTHLY MM
LEFT JOIN MAINTENANCE M ON MM.MAINTENANCE_ID = M.ID
WHERE MM.IS_DELETED IS NOT TRUE
	AND M.IS_DELETED IS NOT TRUE
	AND @WHERESQL
GROUP BY MM.MONTH
ORDER BY MM.MONTH;</value>
  </data>
  <data name="SummaryDLPTotalCasesDefectsProject" xml:space="preserve">
    <value>SELECT M.PROJECT_ID,
	M.PROJECT_NAME,
	COUNT(CM.ID) AS TOTAL_MAINTENANCE
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLCASES
GROUP BY M.PROJECT_ID,
	M.PROJECT_NAME;
	
SELECT M.PROJECT_ID,
	M.PROJECT_NAME,
	COUNT(DM.ID) AS TOTAL_MAINTENANCE
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS
GROUP BY M.PROJECT_ID,
	M.PROJECT_NAME;</value>
  </data>
  <data name="SummaryDLPTotalDefectOverdueType" xml:space="preserve">
    <value>SELECT COUNT(CASE WHEN (DM.COMPLETION_DATE::date - DM.CONFIRMATION_DATE::date) &gt; 30 THEN 1 END) AS OVERDUEMORE30DAYS,
	COUNT(CASE WHEN (DM.COMPLETION_DATE::date - DM.CONFIRMATION_DATE::date) BETWEEN 14 AND 30 THEN 1 END) AS OVERDUE14TO30DAYS,
	COUNT(CASE WHEN (DM.COMPLETION_DATE::date - DM.CONFIRMATION_DATE::date) &lt; 14 THEN 1 END) AS OVERDUEONTRACK
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.COMPLETION_DATE &lt;&gt; 'infinity'::timestamp
	AND DM.COMPLETION_DATE &lt;&gt; '-infinity'::timestamp
	AND DM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
	AND DM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS;</value>
  </data>
  <data name="SummaryDLPTotalDefectOverdueTypeExceeding30Days" xml:space="preserve">
    <value>SELECT DM.TAG,
	M.PROJECT_ID,
	M.PROJECT_NAME,
	COUNT(DM.ID) AS TOTALSTATUS
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.COMPLETION_DATE &lt;&gt; 'infinity'::timestamp
	AND DM.COMPLETION_DATE &lt;&gt; '-infinity'::timestamp
	AND DM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
	AND DM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND (DM.COMPLETION_DATE::date - DM.CONFIRMATION_DATE::date) &gt; 30
	AND @WHERESQLDEFECTS
GROUP BY DM.TAG,
	M.PROJECT_ID,
	M.PROJECT_NAME
UNION
SELECT CM.TAG,
	M.PROJECT_ID,
	M.PROJECT_NAME,
	COUNT(CM.ID) AS TOTALSTATUS
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND CM.CREATION_DATE &lt;&gt; 'infinity'::timestamp
	AND CM.CREATION_DATE &lt;&gt; '-infinity'::timestamp
	AND CM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
	AND CM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
	AND CM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND (CM.CREATION_DATE::date - CM.CONFIRMATION_DATE::date) &gt; 30
	AND @WHERESQLCASES
GROUP BY CM.TAG,
	M.PROJECT_ID,
	M.PROJECT_NAME;</value>
  </data>
  <data name="SummaryDLPTotalDefectOverdueTypeExceeding30DaysDetailCases" xml:space="preserve">
    <value>SELECT 
CM.*,
M.PROJECT_NAME,
M.PROJECT_ID
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND CM.SUBMITTED_DATE &lt;&gt; 'infinity'::timestamp
	AND CM.SUBMITTED_DATE &lt;&gt; '-infinity'::timestamp
	AND CM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
	AND CM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
	AND CM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND (CM.SUBMITTED_DATE::date - CM.CONFIRMATION_DATE::date) &gt; 30
	AND @WHERESQLDEFECTS;</value>
  </data>
  <data name="SummaryDLPTotalDefectOverdueTypeExceeding30DaysDetailDefects" xml:space="preserve">
    <value>SELECT 
DM.*,
M.PROJECT_NAME,
M.PROJECT_ID
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.COMPLETION_DATE &lt;&gt; 'infinity'::timestamp
	AND DM.COMPLETION_DATE &lt;&gt; '-infinity'::timestamp
	AND DM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
	AND DM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND (DM.COMPLETION_DATE::date - DM.CONFIRMATION_DATE::date) &gt; 30
	AND @WHERESQLDEFECTS;</value>
  </data>
  <data name="SummaryDLPTotalDefectOverdueTypeWeek" xml:space="preserve">
    <value>SELECT 
	COUNT(CASE WHEN (DM.CONFIRMATION_DATE::date - DM.TARGET_COMPLETION_DATE::date) &gt; 30 THEN 1 END) AS OVERDUEMORE30DAYS,
	COUNT(CASE WHEN (DM.CONFIRMATION_DATE::date - DM.TARGET_COMPLETION_DATE::date) BETWEEN 14 AND 30 THEN 1 END) AS OVERDUE14TO30DAYS,
	COUNT(CASE WHEN (DM.CONFIRMATION_DATE::date - DM.TARGET_COMPLETION_DATE::date) &lt; 14 THEN 1 END) AS OVERDUEONTRACK,
	@STARTWEEK AS StartWeek,
	@ENDWEEK AS EndWeek
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.TARGET_COMPLETION_DATE &lt;&gt; 'infinity'::timestamp 
	AND DM.TARGET_COMPLETION_DATE &lt;&gt; '-infinity'::timestamp
	AND DM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp 
	AND DM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
	AND TYPE_WARRANTY = 'DLP'
	AND DM.IS_DELETED IS NOT TRUE
	AND @WHERESQLDEFECTS;</value>
  </data>
  <data name="SummaryDLPTotalDefectsStatues" xml:space="preserve">
    <value>SELECT
	DM.STATUS,
	COUNT(DM.ID) AS TOTAL_MAINTENANCE
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS
GROUP BY
	DM.STATUS;</value>
  </data>
  <data name="SummaryDLPTotalDefectsStatuesProject" xml:space="preserve">
    <value>SELECT M.PROJECT_ID,
	M.PROJECT_NAME,
	DM.STATUS,
	COUNT(DM.ID) AS TOTAL_MAINTENANCE
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS
GROUP BY M.PROJECT_ID,
	M.PROJECT_NAME,
	DM.STATUS;</value>
  </data>
  <data name="SummaryDLPTotalDefectsStatuesProjectDateTime" xml:space="preserve">
    <value>SELECT MAX(WORK_START_DATE) AS MAXDATE,
	MIN(WORK_START_DATE) AS MINDATE,
	MAX(TARGET_COMPLETION_DATE) AS EXPECTED_TOP_DATE
FROM CASES_MONITORING DM
WHERE ISFINITE(WORK_START_DATE) = TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND DM.WORK_START_DATE &lt;&gt; 'infinity'::timestamp
	AND DM.WORK_START_DATE &lt;&gt; '-infinity'::timestamp
	AND DM.TARGET_COMPLETION_DATE &lt;&gt; 'infinity'::timestamp
	AND DM.TARGET_COMPLETION_DATE &lt;&gt; '-infinity'::timestamp
	AND DM.WORK_START_DATE &lt;&gt; '1970-01-01'
	AND @WHERESQLDEFECTS;</value>
  </data>
  <data name="SummaryDLPTotalDefectsStatuestTimeline" xml:space="preserve">
    <value>SELECT 
	EXTRACT(MONTH FROM DM.TARGET_COMPLETION_DATE) AS MONTH,
	EXTRACT(YEAR FROM DM.TARGET_COMPLETION_DATE) AS YEAR,
	CONCAT(EXTRACT(MONTH FROM DM.TARGET_COMPLETION_DATE), '-',  substring(CAST (EXTRACT(YEAR FROM DM.TARGET_COMPLETION_DATE) AS VARCHAR) from 3 for 4)) AS DATE_CONCAT,
	DM.STATUS,
	COUNT(DM.ID) AS TOTAL_MAINTENANCE
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND DM.TARGET_COMPLETION_DATE &lt;&gt; 'infinity'::timestamp 
	AND DM.TARGET_COMPLETION_DATE &lt;&gt; '-infinity'::timestamp
	AND @WHERESQLDEFECTS
GROUP BY YEAR, MONTH, DATE_CONCAT,
	DM.STATUS
ORDER BY YEAR, MONTH, DATE_CONCAT;</value>
  </data>
  <data name="SummaryDLPTotalWaterSeepagesChokagesStatus" xml:space="preserve">
    <value>SELECT DM.STATUS AS STATUS,
	COUNT(DM.ID) AS TOTAL_MAINTENANCE
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE LOWER(DESCRIPTION) like LOWER('%Water Seepage%')
	AND M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS
GROUP BY DM.STATUS;


SELECT DM.STATUS AS STATUS,
	COUNT(DM.ID) AS TOTAL_MAINTENANCE
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE LOWER(DESCRIPTION) like LOWER('%Chokage%')
	AND M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS
GROUP BY DM.STATUS;</value>
  </data>
  <data name="SummaryDLPTotalWaterSeepagesChokagesStatusDetailCases" xml:space="preserve">
    <value>SELECT *
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE (LOWER(LATEST_COMMENT) like LOWER('%Water Seepage%') OR LOWER(LATEST_COMMENT) like LOWER('%Chokage%'))
	AND M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS;</value>
  </data>
  <data name="SummaryDLPTotalWaterSeepagesChokagesStatusDetailDefects" xml:space="preserve">
    <value>SELECT *
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE (LOWER(DESCRIPTION) like LOWER('%Water Seepage%') OR LOWER(DESCRIPTION) like LOWER('%Chokage%'))
	AND M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS;</value>
  </data>
  <data name="SummaryDLPTotalWaterSeepagesChokagesStatusDetailTimeLineCases" xml:space="preserve">
    <value>SELECT DM.CREATION_DATE,
	COUNT(DM.ID) AS TOTAL
FROM CASES_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE (LOWER(LATEST_COMMENT) like LOWER('%Water Seepage%')
							OR LOWER(LATEST_COMMENT) like LOWER('%Chokage%'))
	AND M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS
GROUP BY DM.CREATION_DATE
ORDER BY DM.CREATION_DATE;</value>
  </data>
  <data name="SummaryDLPTotalWaterSeepagesChokagesStatusDetailTimeLineDefects" xml:space="preserve">
    <value>SELECT 
	CONCAT(EXTRACT(MONTH FROM DM.CREATION_DATE), '-',  substring(CAST (EXTRACT(YEAR FROM DM.CREATION_DATE) AS VARCHAR) from 3 for 4)) AS CREATION_DATE,
	COUNT(DM.ID) AS TOTAL
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE (LOWER(DESCRIPTION) like LOWER('%Water Seepage%')
							OR LOWER(DESCRIPTION) like LOWER('%Chokage%'))
	AND M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND TYPE_WARRANTY = 'DLP'
	AND @WHERESQLDEFECTS
GROUP BY DM.CREATION_DATE
ORDER BY DM.CREATION_DATE;</value>
  </data>
  <data name="SummaryDLPTotalWorkersOnSite" xml:space="preserve">
    <value>SELECT  MM.MONTH,
	SUM(MM.TOTAL_WORKERS_ON_SITE) AS TOTAL_WORKERS_ON_SITE,
	SUM(MM.TOTAL_WH_WORKERS_ON_SITE) AS TOTAL_WH_WORKERS_ON_SITE
FROM MAINTENANCE_MONTHLY MM
LEFT JOIN MAINTENANCE M ON MM.MAINTENANCE_ID = M.ID
WHERE MM.IS_DELETED IS NOT TRUE
	AND M.IS_DELETED IS NOT TRUE
	AND @WHERESQL
	AND MM.MONTH &gt;= @START_MONTH
	AND MM.MONTH &lt;= @END_MONTH  GROUP BY MM.MONTH ORDER BY MM.MONTH ;</value>
  </data>
  <data name="SummaryPostDLPIncomingOutgoing" xml:space="preserve">
    <value>-- DEFECTS OVERVIEW INCOMMING AND OUTGOING

SELECT COUNT(CASE
			 WHEN DM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
			 AND DM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
			 AND ((LOWER(DM.STATUS) LIKE '%wip%' OR LOWER(DM.STATUS) LIKE '%ps%')) THEN 1 END) AS TOTALINCOMING,
	COUNT(CASE
		  WHEN DM.CLOSING_DATE &lt;&gt; 'infinity'::timestamp
		  AND DM.CLOSING_DATE &lt;&gt; '-infinity'::timestamp
		  AND LOWER(DM.STATUS) LIKE '%close%' THEN 1 END) AS TOTALOUTGOING
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE DM.TYPE_WARRANTY = 'PostDLP'
	AND M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND @WHERESQLDEFECTS;

-- CASES OVERVIEW INCOMMING AND OUTGOING

SELECT COUNT(CASE
			 WHEN CM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
			 AND CM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
			 AND ((LOWER(CM.STATUS) LIKE '%wip%' OR LOWER(CM.STATUS) LIKE '%ps%')) THEN 1 END) AS TOTALINCOMING,
	 COUNT(CASE
		  WHEN CM.CLOSING_DATE &lt;&gt; 'infinity'::timestamp
		  AND CM.CLOSING_DATE &lt;&gt; '-infinity'::timestamp
		  AND LOWER(CM.STATUS) LIKE '%close%' THEN 1 END) AS TOTALOUTGOING
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE CM.TYPE_WARRANTY = 'PostDLP'
	AND M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND @WHERESQLCASES;
	
	
-- DEFECTS INCOMING
SELECT
	CONCAT(EXTRACT(MONTH FROM DM.CONFIRMATION_DATE), '-', EXTRACT(YEAR FROM DM.CONFIRMATION_DATE)) AS DATE_CONCAT,
	COUNT(DM.ID) AS TOTAL
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE DM.TYPE_WARRANTY = 'PostDLP'
	AND M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND DM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
	AND DM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
	AND (LOWER(DM.STATUS) LIKE '%wip%'
						OR LOWER(DM.STATUS) LIKE '%ps%')
	AND @WHERESQLDEFECTS
GROUP BY DATE_CONCAT
ORDER BY DATE_CONCAT;

-- DEFECTS OUTGOING
SELECT
	CONCAT(EXTRACT(MONTH FROM DM.CLOSING_DATE), '-', EXTRACT(YEAR FROM DM.CLOSING_DATE)) AS DATE_CONCAT,
	COUNT(DM.ID) AS TOTAL
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE DM.TYPE_WARRANTY = 'PostDLP'
	AND M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND DM.CLOSING_DATE &lt;&gt; 'infinity'::timestamp
	AND DM.CLOSING_DATE &lt;&gt; '-infinity'::timestamp
	AND LOWER(DM.STATUS) LIKE '%close%'
	AND @WHERESQLDEFECTS
GROUP BY DATE_CONCAT
ORDER BY DATE_CONCAT;


-- CASES TIMELINE INCOMING AND OUTGOING
-- CASES INCOMING

SELECT
	CONCAT(EXTRACT(MONTH FROM CM.CONFIRMATION_DATE), '-', EXTRACT(YEAR FROM CM.CONFIRMATION_DATE)) AS DATE_CONCAT,
	COUNT(CM.ID) AS TOTAL
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE CM.TYPE_WARRANTY = 'PostDLP'
	AND M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND CM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
	AND CM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
	AND (LOWER(CM.STATUS) LIKE '%wip%'
						OR LOWER(CM.STATUS) LIKE '%ps%')
	AND @WHERESQLCASES
GROUP BY DATE_CONCAT
ORDER BY DATE_CONCAT;

-- CASES OUTGOING

SELECT 
	CONCAT(EXTRACT(MONTH FROM CM.CLOSING_DATE), '-', EXTRACT(YEAR FROM CM.CLOSING_DATE)) AS DATE_CONCAT,
	COUNT(CM.ID) AS TOTAL
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE CM.TYPE_WARRANTY = 'PostDLP'
	AND M.IS_DELETED IS NOT TRUE
	AND CM.IS_DELETED IS NOT TRUE
	AND CM.CLOSING_DATE &lt;&gt; 'infinity'::timestamp
	AND CM.CLOSING_DATE &lt;&gt; '-infinity'::timestamp
	AND LOWER(CM.STATUS) LIKE '%close%'
	AND @WHERESQLCASES
GROUP BY DATE_CONCAT
ORDER BY DATE_CONCAT;</value>
  </data>
  <data name="SummaryPostDLPTop10Defects" xml:space="preserve">
    <value>SELECT COUNT(DM.ID) AS TOTALSTATUS,
	TYPE AS TYPEMAINTENANCE
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND DM.TYPE_WARRANTY = 'PostDLP'
	AND @WHERESQLDEFECTS
GROUP BY TYPE
ORDER BY TOTALSTATUS DESC
LIMIT 10;</value>
  </data>
  <data name="SummaryPostDLPTop10DefectsStatus" xml:space="preserve">
    <value>SELECT DM.STATUS,
	COUNT(DM.ID) AS TOTALSTATUS,
	DM.TYPE AS TYPEMAINTENANCE
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND DM.TYPE_WARRANTY = 'PostDLP'
	AND @WHERESQLDEFECTS
GROUP BY DM.STATUS,
	DM.TYPE
ORDER BY TOTALSTATUS DESC;</value>
  </data>
  <data name="SummaryPostDLPTotalDefectsCasesOverviewTimeout" xml:space="preserve">
    <value>-- Total defects
SELECT 
COUNT(DM.ID) AS TOTAL,
@STARTWEEK AS STARTWEEK,
@ENDWEEK AS ENDWEEK
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.TYPE_WARRANTY = 'PostDLP'
	AND DM.IS_DELETED IS NOT TRUE
	AND @WHERESQLDEFECTS;
	
-- Total cases
SELECT 
COUNT(CM.ID) AS TOTAL,
@STARTWEEK AS STARTWEEK,
@ENDWEEK AS ENDWEEK
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND CM.TYPE_WARRANTY = 'PostDLP'
	AND CM.IS_DELETED IS NOT TRUE
	AND @WHERESQLCASES;</value>
  </data>
  <data name="SummaryPostDLPTotalDefectsCasesOverviewTimeoutTimeLine" xml:space="preserve">
    <value>-- Timeline cases
SELECT 
	EXTRACT(MONTH FROM CM.CONFIRMATION_DATE) AS MONTH,
	EXTRACT(YEAR FROM CM.CONFIRMATION_DATE) AS YEAR,
	CONCAT(EXTRACT(MONTH FROM CM.CONFIRMATION_DATE), '-', substring(CAST (EXTRACT(YEAR FROM CM.CONFIRMATION_DATE) AS VARCHAR) from 3 for 4)) AS DATE_CONCAT,
	COUNT(CM.ID) AS TOTAL
FROM CASES_MONITORING CM
LEFT JOIN MAINTENANCE M ON CM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND CM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
  	AND CM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
	AND CM.TYPE_WARRANTY = 'PostDLP'
	AND CM.IS_DELETED IS NOT TRUE
	AND @WHERESQLCASES
GROUP BY MONTH, YEAR, DATE_CONCAT
ORDER BY YEAR, MONTH, DATE_CONCAT;

-- Timeline defects
SELECT 
	EXTRACT(MONTH FROM DM.CONFIRMATION_DATE) AS MONTH,
	EXTRACT(YEAR FROM DM.CONFIRMATION_DATE) AS YEAR,
	CONCAT(EXTRACT(MONTH FROM DM.CONFIRMATION_DATE), '-', substring(CAST (EXTRACT(YEAR FROM DM.CONFIRMATION_DATE) AS VARCHAR) from 3 for 4)) AS DATE_CONCAT,
	COUNT(DM.ID) AS TOTAL
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.CONFIRMATION_DATE &lt;&gt; 'infinity'::timestamp
  	AND DM.CONFIRMATION_DATE &lt;&gt; '-infinity'::timestamp
	AND DM.TYPE_WARRANTY = 'PostDLP'
	AND DM.IS_DELETED IS NOT TRUE
	AND @WHERESQLDEFECTS
GROUP BY MONTH, YEAR, DATE_CONCAT
ORDER BY YEAR, MONTH, DATE_CONCAT;</value>
  </data>
  <data name="SummaryPostDLPTotalDefectsStatus" xml:space="preserve">
    <value>-- overview

SELECT DM.STATUS,
	COUNT(DM.ID) AS TOTALSTATUS
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND DM.TYPE_WARRANTY = 'PostDLP'
	AND @WHERESQLDEFECTS
GROUP BY DM.STATUS
ORDER BY DM.STATUS;

-- timeline

SELECT DM.STATUS,
	CONCAT(EXTRACT(MONTH FROM DM.CONFIRMATION_DATE), '-', EXTRACT(YEAR FROM DM.CONFIRMATION_DATE)) AS DATE_CONCAT,
	COUNT(DM.ID) AS TOTALSTATUS
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE M.IS_DELETED IS NOT TRUE
	AND DM.IS_DELETED IS NOT TRUE
	AND DM.TYPE_WARRANTY = 'PostDLP'
	AND @WHERESQLDEFECTS
GROUP BY DM.STATUS,
	DATE_CONCAT
ORDER BY DM.STATUS,
	DATE_CONCAT;

-- detail
SELECT DM.ID,
	DM.MAINTENANCE_ID,
	DM.BLOCK,
	DM.LEVEL,
	DM.UNIT,
	DM.CASE_NUMBER,
	DM.LOCATION,
	DM.TYPE,
	DM.DESCRIPTION,
	DM.TAG,
	DM.UPDATED_AT,
	DM.UPDATED_BY,
	DM.STATUS,
	DM.NB_DAYS_OPEN
FROM DEFECTS_MONITORING DM
LEFT JOIN MAINTENANCE M ON DM.MAINTENANCE_ID = M.ID
WHERE DM.TYPE_WARRANTY = 'PostDLP'
AND @WHERESQLDEFECTS;</value>
  </data>
</root>